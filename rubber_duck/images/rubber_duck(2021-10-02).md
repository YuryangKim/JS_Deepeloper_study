---
date: 2021-10-02-Saturday
---

# JS Deepveloper's study

## 4장: 변수

- [ ]  변수의 정의와 필요성?
- [ ]  식별자와 변수의 차이점?
- [ ]  변수 선언 방법 (키워드 3가지)?
- [ ]  변수 선언의 실행 시점과 변수 호이스팅?
- [ ]  const 키워드를 사용하면 상수를 만들 수 있다. 
하지만 간혹 이런 상수를 "변수"라고 부르기도 한다. 그 이유는? 
(📍**HINT**: var/let/const 키워드로 변수를 선언하고 난 뒤 처음 하는 할당이 사실은 재할당이기도 한 것과 연관있음.)

## 5장: 표현식과 문

### 5.1. 값

- [ ]  값과 표현식과의 관계는? 그리고 여기서 JS 엔진의 역활은?
    - cf. 변수 선언 → 할당(재할당), 값이 "평가 되어지는 때"는 언제?
    - 변수 선언부터 값의 할당 과정이 컴퓨터 메모리에서 어떤 식으로 진행되는지 서술하시오.
    - 해설 (click me!!)
        
        값은 표현식이 JS 엔진에 의해 평가되어지는 결과값을 의미한다. 그리고 여기서 JS 엔진의 평가는 (이미 undefined라는 초깃값을 갖고있는 상태의 변수에게) 할당 이전에 이루어져야한다. 왜냐면 실질적으로 새롭게 확보된 메모리셀에 들어가는 실체는 평가되어진 값이지 표현식이 아니기 때문이다. 
        

### 5.2. 리터럴

- [ ]  리터럴의 정의와 목적?
    - 해설 (click me!!)
        
        리터럴은 사람이 이해할 수 있는 문자 또는 미리 약속된 기호를 (JS엔진이) 평가해 값을 생성하게끔 하는 표기법이다. ~~이때, JS 엔진이 값을 평가해 값을 생성한느 것은 런타임이다~~. 
        다시... 리터럴이 필요한 이유는 .. 
        우리는 우리가 알아듣고, 사용할 수있는 리터럴이라는 표기법으로 JS 엔진에게 값을 생성해 달라고 할 수 있는 것이다! 
        

### 5.3. 표현식

- [ ]  표현식이란?
    - 해설 (click me!!)
        
        값으로 평가될 수 있는 문을 의미한다. 
        다만, 뒤에서 살펴볼 문(statement)은 표현식(expression)인 문과 표현식이 아닌 문이 있기 때문에 개념이 뒤섞이지 않게 조심!
        

### 5.4. 문

- [ ]  문이란? 문을 구성하는 단위를 뭐라 부르는가? 문의 역할?
    - 해설 (click me!!)
        - 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 
        문이 모여모여 집합을 이루면 그것이 바로 프로그램이라고 할 수 있다.
        - 문이라는 하나의 개념 덩어리 안에 더 자세히 들여다보면, 문을 구성하는 "토큰"이란 아이들이 있다. 
        이 토큰(token)은 "문법적인 의미를 가지면, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소"를 의미한다.
        e.g. 키워드, 식별자, 연산자, 리터럴, 세미톨론, 마침표 등...
        - 문은 명령문이라고도 부른다. 
        문의 종류가 선언문이면 변수같은 것을 선언할 수 있고, 할당문이면 변수에 값을 할당할 수 있다. 
        즉, 컴퓨터에 명령을 내리는 역할을 맡고 있는 것이 바로 "문"이라고 할 수 있겠다.
        

### 5.6. 표현식인 문과 표현식이 아닌 문

- [ ]  "표현식인 문"과 "표현식이 아닌 문"의 차이점을 서술하시오.
    - 해설 (click me!!)
        - 표현식인 문:
            - 값으로 평가되는 문
                - e.g.
                    
                    x = 100;   // 할당문 → 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 
                    
                                     // 즉, 할당문은 표현식인 문이다.
                    
        - 표현식이 아닌 문:
            - 값으로 평가되지 않는 문
                - e.g.
                    
                    var x;      // 변수 선언문 → 표현식이 아닌 문
                    
        - **구별 방법** (📍중요📍):
            - *변수에 할당할 수 있으면 표현식, 에러가 뜨면 표현식* **X**
                - e.g.
                    
                    var foo = var x;      // **X** !!! → **Syntax Error...**
                    
                    var foo = ** x = 100;**  // 여기서  **x = 100** 은 값처럼 사용이 가능하다 
                    
                                                     // → 즉,  **x = 100** 은 표현식이다.
                    
        

## 6장: 데이터 타입

- [ ]  JS 의 데이터 타입은 총 몇개? 타입들은 2가지의 값의 종류로 나뉜다. 나열하시오.
    - 해설 (click me!!)
        - 총 7개의 데이터 타입이 있다.
            1. 원시 타입 
                1. 숫자 타입 
                2. 문자열 타입
                3. 불리언 타입 
                4. undefined 타입
                5. null 타입 
                6. 심벌 타입
            2. 객체 타입
                1. 원시타입이 아닌 모든 데이터가 여기로 분류된다.
                    
                    e.g. 객체, 함수, 배열 등
                    
            
            으로 나뉜다. 
            

### 6.1. 숫자 타입

- [ ]  다른 기타 언어들과는 다르게 JS 에서는 하나의 숫자 타입만 존재한다.
    
    📍YES / NO 퀴즈📍
    
    - console.log(1 === 1.0);
        - 해설 (click me!!)
            
            **YES**
            → 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없기 때문에 모든 수를 "실수(**☝️**유리수, 무리수, 정수, 정수 아닌 유리수...모두모두 그냥 실수로 **퉁☝️**)"로 처리한다.
            → 이때, == 는 엄격하지 않은 이퀄 사인, === 는 엄격하게 둘이 타입까지 같은지 물어보는 연산자인 것 기억하고 가기 😉
            

### 6.2. 문자열 타입

- [ ]  문자열을 감쌀 때 사용할 수 있는 기호 3가지가 있다. 이때, ES5 이하에서는 사용할 수 없는 기호는?
    - 해설 (click me!!)
        
        백틱 (``) 은 ES6 이후부터 사용 가능.
        
- [ ]  템플릿 리터럴을 사용하면 이런게 가능해요!! 
   → 템플릿 리터럴로 ES6부터 간편하게 사용가능해진 3가지의 기능은?
    - 해설 (click me!!)
        - 멀티라인 문자열 (개행)
            - e.g.
                
                [템플릿 리터럴 **X**]
                
                var template = '<ul>**\n\t**<li><a href="#">Home</a></li>**\n**</ul>';   
                
                                     // → 원래는 이런 이스케이프 시퀀스를 사용했어야만 했음
                
                [템플릿 리터럴 **O**]
                
                var template = **`**<ul> 
                                               <li><a href="#">Home</a></li>
                
                                           </ul>**`**;
                
        - 표현식 삽입 (+ 연결 연산자로 하나 이상의 문자열을 연결할 수 있다) / 태그드 템플릿 (${변수명})
            - e.g.
                
                [템플릿 리터럴 **X**]
                
                var first = 'Nice';
                
                var last = 'you';
                
                console.log(first + 'to meet' + last);
                
                [템플릿 리터럴 **O**]
                
                var first = 'Nice';
                
                var last = 'you';
                
                console.log(**`${**first**}** to meet **${**last**}**!**`**);
                

### 6.5. undefined 타입

- [ ]  typeof(변수명);     // undefined 가 의미하는 바는?
    - 해설 (click me!!)
        - 변수를 참조했을 때/변수의 타입을 확인했을 때 undefined가 반환된다면 해당 변수가 선언 이후 값이 할당된 적이 없는, 즉 값이 할당된 적이 없고 선언만 된 상태의 변수라는 것을 알 수 있다.
        

### 6.6. null 타입

- [ ]  null 값의 의미는? null 과 undefined의 다른점?
    - 해설 (click me!!)
        - 프로그래밍 언어에서 null은 변수에 값이 없는 상태라는 것을 의도적으로 명시(cf. 의도적 부재 = intentional absence)할 때 사용한다.
        개발자가 변수에 null 이라는 값을 할당하는 것은 변수가 이전에 참조하고 있던 값/ 이전에 할당되었던 값을 더 이상은 참조하지 않겠다는 의미다. 
        이는 이전에 할당되어 있던 값을 명시적으로 제거하는 것이며, *JS 엔진은 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행*한다.
        
- [ ]  null, Null, NULL은 모두 null 값을 의미할까요?
    - 해설 (click me!!)
        - 아니다!! 자바스크립트는 대소문자를 구별하기 때문에 셋다 다르다.
        

### 6.7. 심벌 타입

- [ ]  ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
심벌값은 다른 값과 중복되지 않는 **유일무이한 값**이다.
심벌 이외의 다른 원시 타입의 값들은 "리터럴"을 통해 생성하지만, 심벌은 Symbol 함수를 호출해 생성한다는 차이점이 있다. 
이렇게 Symbol 함수를 통해 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유니크한 값이된다.
    
    e.g. 
    
    var **key** = **Symbol(**'key'**)**; 
    console.log(**typeof** **key**);      // **symbol** 
    

### 6.9. 데이터 타입의 필요성

- [ ]  ~~(필요시 설명 고고 → cf. 68 ~)~~

### 6.10. 동적 타이핑

- [ ]  C나 자바 같은 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야한다. 이를 **명시적 타입 선언** 이라 하는데,  명시적 타입 선언을 한 뒤, 변수에는 사전에 정해준 타입의 값만 들어갈 수 있게된다. 이런 특성을 갖고 있는 언어를 **정적 타입 언어** 라고 한다.
- [ ]  하지만 자바스크립트는 동적 타입 언어로, 변수를 선언할 때 따로 변수에 어떤 타입의 데이터를 넣을 것인지 설정을 안해도 되고, 이후에도 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 
그래서... 이걸 다시 설명하자면...
자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 
(cf. JS 엔진이 타입을 guess 하는거 → 이를 **타입 추론** 이라고 한다.) 
그리고 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있다는 의미에서 이런 특징을 **동적 타이핑** 이라고 하고, 이런 특징을 갖고 있는 언어를 **동적 타입 언어**라고 부른다.  
    👉 <extra> 동적 타입 언어는 정적 타입 언어보다 유연성은 높지만 신뢰성은 떨어진다 🥲

## 7장: 연산자

- [ ]  ~~질문 있으면 고고!~~

## 8장: 제어문

- [ ]  제어문: 코드의 실행 흐름을 인위적으로 제어한다 해서 제어문이라고 한다
- [ ]  제어문
    - 블록문
    - 조건문
    - 반복문

### 8.1. 블록문

- [ ]  정의:
    - 0개 이상의 문을 중괄호로 묶은 것으로 **코드블록** 또는 **블록**이라고 부르기도 한다.
    - JS는 블록문을 하나의 실행 단위로 취급하기 때문에 **자체 종결성**을 갖기때문에 ~~통상적으로 문의 끝에는 세미콜론을 붙여 JS 엔진에게 여기가 코드가 끝나는 시점이란 것을 알려주지만~~ 블록문 뒤에 세미콜론을 붙이지 않는다.

### 8.2. 조건문

- [ ]  정의:
    - 조건식은 불리언 값 (true/false)로 평가될 수 있는 표현식을 의미한다.
    - JS 는 2가지의 조건문을 제공한다 → **if else 문,** **switch문**

### 8.3. 반복문

- [ ]  정의:
    - 반복문은 조건식의 평가 결과가 참일때 코드 블록을 실행하고, 코드 블록 실행을 끝낸 뒤 조건식을 다시 평가하여 여전히 참일때는 코드블록을 다시 실행하지만, 조건식이 거짓이면 코드 블록 실행을 그만하는 문을 의미한다.
    위의 과정이 조건식이 거짓일 때까지 반복된다 해서 반복문이라고 한다.
    - JS는 3가지의 반복문을 제공한다 → **for문**, **while문**, **do ... while문**

### 8.4. break문

- [ ]  정의:
    - 코드 블록 — 더 정확히는 레이블문, 반복문, 또는 switch문의 코드블록 — 을 탈출하는 문
    📍 위에서 언급된 문들 외에서 break 문을 사용하면 문법 에러(SyntaxError)가 발생한다 📍

### 8.5. continue문

- [ ]  정의:
    - break 문처럼 문을 탈출하는 것은 아니지만, continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. 
    (☝️cf. 106쪽 예시 코드 참고!☝️)

## 9장: 타입 변환과 단축 평가

### 9.3. 명시적 타입 변환

- [ ]  명시적 타입 변환이란? 이를 부르는 다른 이름으로는 뭐라 부르나요?
    - 해설 (click me!!)
        
        JS 모든 값은 타입이 있다고 했는데, 값의 타입을 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 이렇게 의도적으로 값의 타입을 변환하는 행위를 **명시적 타입 변환**이라고 하고, 다른 말로는 **타입 캐스팅** 이라고 부른다.   
        
- [ ]  그렇담 암묵적 타입 변환은 뭔가요?
    - 해설 (click me!!)
        
        명시적으로 개발자가 타입을 변환하겠다고 한것이 아님에도 불구하고 JS 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환/ 암묵적으로 타입 변환을 해주는 것을 의미한다.
        

### 9.4. 단축 평가

- [ ]  정의:
    - 표현식을 평가하는 도중에 평가 결과가 측정된 경우 나머지 평가 과정을 생략하는 것을 의미한다.
    - 단축 평가에서는
        - 논리곱 (&&)
        - 논리합 (||)
            
            즉, 논리 연산자를 사용한다. 
                 e.g. 
                 let done = true; 
                 let message = '';
                 if (done) message = '완료';   
            
                // 위의 코드를 단축 평가로 대체하면 아래와 같다 
            
                message = done && '완료'; 
                console.log(messge);              // '완료'
            
            - 📍 *헷갈린다면 요거 클릭* !! 😉
                
                true    &&   **true** 
                
                true    &&   **false**
                
                **false**   &&   true 
                
                **false**   &&   false
                
                **true**     ||   true 
                
                **true**     ||   false 
                
                false    ||   **true** 
                
                false    ||   **false**
